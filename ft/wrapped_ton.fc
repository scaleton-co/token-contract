int equal_slices (slice s1, slice s2) asm "SDEQ";
cell token_code() asm "ft_code PUSHREF";

() mint_wtons (slice to, int amount) impure {
  cell state_init = calculate_token_state_init(to, my_address(), token_code());
  slice to_wallet = calc_address(state_init);
  var msg = begin_cell()
    .store_uint(0x18, 6)
    .store_slice(to_wallet)
    .store_coins(40000000)
    .store_uint(4 + 2 + 0, 1 + 4 + 4 + 64 + 32 + 1 + 1 + 1)
    .store_ref(state_init)
    .store_uint(op::master_request, 32)
    .store_uint(cur_lt(), 64)
    .store_coins(amount);
  send_raw_message(msg.end_cell(), 0);
}

() release_tons (slice in_msg, slice sender) impure {
  int query_id = in_msg~load_uint(64);
  int amount = in_msg~load_coins();
  slice from = in_msg~load_msg_addr();
  throw_unless(707,
      equal_slices(calc_user_wallet(from, my_address(), token_code()), sender)
  );
  ;; Good idea to track amount of minted wtons, reserve them and send everything else
  ;; to the user
  var msg = begin_cell()
    .store_uint(0x10, 6) ;; nobounce - int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool src:MsgAddress -> 011000
    .store_slice(from)
    .store_coins(amount)
    .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
    .store_uint(op::released_tons, 32)
    .store_uint(query_id, 64);
  send_raw_message(msg.end_cell(), 64);
}

() recv_internal(int msg_value, cell in_msg_cell, slice in_msg) impure {

  slice cs = in_msg_cell.begin_parse();
  int flags = cs~load_uint(4);
  if (flags & 1) {
    return ();
  }
  slice sender = cs~load_msg_addr();
  
  int op = in_msg~load_uint(32);

  if(op == op::wrap_my_tons) { ;; token owner command
    msg_value -= 50000000;
    return mint_wtons(sender, msg_value);
  }
  if(op == op::burn_notification) { ;; unwrap my tons
    return release_tons(in_msg, sender);
  }

  throw(1111);
}

(int, int, slice, cell) get_jetton_data() method_id {
  return (pair_first(get_balance()), ;; rough but close to reality
          -1,
          begin_cell().store_uint(0,2).end_cell().begin_parse(),
          begin_cell().end_cell());
}
